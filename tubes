#!/usr/bin/env python3

import os
import signal
import time
from subprocess import Popen, PIPE
from pathlib import Path
from tempfile import gettempdir

import gi

gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import GLib, Gtk
from gi.repository import AppIndicator3


GREEN_PIPE = """<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 14 16"
shape-rendering="crispEdges"><path stroke="rgba(0,0,0,0.5019607843137255)" d="M4 0h6M2
1h2M10 1h2M0 2h2M12 2h2M0 3h1M13 3h1M0 4h1M13 4h1M0 5h1M13 5h1M0 6h1M13 6h1M1 7h1M12
7h1M1 8h1M12 8h1M1 9h1M12 9h1M1 10h1M12 10h1M1 11h1M12 11h1M1 12h1M12 12h1M1 13h2M11
13h2M2 14h2M10 14h2M3 15h8" /> <path stroke="#88f888" d="M4 1h6M2 2h2M10 2h2M2 3h1M11
3h1M2 4h2M10 4h1M2 5h8M2 6h2M9 6h1M3 7h1M9 7h1M3 9h2M3 10h2M8 10h1M3 11h2M8 11h1M3
12h2M8 12h1M3 13h2M8 13h1M4 14h1M8 14h1" /> <path stroke="#000000" d="M4 2h6M3 3h8M4
4h6M2 7h1M11 7h1M3 8h2M9 8h2M5 9h4" /> <path stroke="#58d058" d="M1 3h1M1 4h1M1 5h1M1
6h1M4 6h4M4 7h4M2 8h1M5 8h3M2 9h1M2 10h1M5 10h2M2 11h1M5 11h2M2 12h1M5 12h2M5 13h2M5
14h2" /> <path stroke="#28a028" d="M12 3h1M11 4h2M10 5h3M8 6h1M10 6h3M8 7h1M10 7h1M8
8h1M11 8h1M9 9h3M7 10h1M9 10h3M7 11h1M9 11h3M7 12h1M9 12h3M7 13h1M9 13h2M7 14h1M9 14h1"
/> </svg>
"""

YELLOW_PIPE = """<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 14 16"
shape-rendering="crispEdges"><path stroke="rgba(0,0,0,0.5019607843137255)" d="M4 0h6M2
1h2M10 1h2M0 2h2M12 2h2M0 3h1M13 3h1M0 4h1M13 4h1M0 5h1M13 5h1M0 6h1M13 6h1M1 7h1M12
7h1M1 8h1M12 8h1M1 9h1M12 9h1M1 10h1M12 10h1M1 11h1M12 11h1M1 12h1M12 12h1M1 13h2M11
13h2M2 14h2M10 14h2M3 15h8" /> <path stroke="#f8e2bf" d="M4 1h6M2 2h2M10 2h2M2 3h1M11
3h1M2 4h2M10 4h1M2 5h8M2 6h2M9 6h1M3 7h1M9 7h1M3 9h2M3 10h2M8 10h1M3 11h2M8 11h1M3
12h2M8 12h1M3 13h2M8 13h1M4 14h1M8 14h1" /> <path stroke="#000000" d="M4 2h6M3 3h8M4
4h6M2 7h1M11 7h1M3 8h2M9 8h2M5 9h4" /> <path stroke="#f2ca89" d="M1 3h1M1 4h1M1 5h1M1
6h1M4 6h4M4 7h4M2 8h1M5 8h3M2 9h1M2 10h1M5 10h2M2 11h1M5 11h2M2 12h1M5 12h2M5 13h2M5
14h2" /> <path stroke="#ebab44" d="M12 3h1M11 4h2M10 5h3M8 6h1M10 6h3M8 7h1M10 7h1M8
8h1M11 8h1M9 9h3M7 10h1M9 10h3M7 11h1M9 11h3M7 12h1M9 12h3M7 13h1M9 13h2M7 14h1M9 14h1"
/> </svg>"""

RED_PIPE = """<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -0.5 14 16"
shape-rendering="crispEdges"><path stroke="rgba(0,0,0,0.5019607843137255)" d="M4 0h6M2
1h2M10 1h2M0 2h2M12 2h2M0 3h1M13 3h1M0 4h1M13 4h1M0 5h1M13 5h1M0 6h1M13 6h1M1 7h1M12
7h1M1 8h1M12 8h1M1 9h1M12 9h1M1 10h1M12 10h1M1 11h1M12 11h1M1 12h1M12 12h1M1 13h2M11
13h2M2 14h2M10 14h2M3 15h8" /> <path stroke="#eac1c1" d="M4 1h6M2 2h2M10 2h2M2 3h1M11
3h1M2 4h2M10 4h1M2 5h8M2 6h2M9 6h1M3 7h1M9 7h1M3 9h2M3 10h2M8 10h1M3 11h2M8 11h1M3
12h2M8 12h1M3 13h2M8 13h1M4 14h1M8 14h1" /> <path stroke="#000000" d="M4 2h6M3 3h8M4
4h6M2 7h1M11 7h1M3 8h2M9 8h2M5 9h4" /> <path stroke="#d58282" d="M1 3h1M1 4h1M1 5h1M1
6h1M4 6h4M4 7h4M2 8h1M5 8h3M2 9h1M2 10h1M5 10h2M2 11h1M5 11h2M2 12h1M5 12h2M5 13h2M5
14h2" /> <path stroke="#ba3e3e" d="M12 3h1M11 4h2M10 5h3M8 6h1M10 6h3M8 7h1M10 7h1M8
8h1M11 8h1M9 9h3M7 10h1M9 10h3M7 11h1M9 11h3M7 12h1M9 12h3M7 13h1M9 13h2M7 14h1M9 14h1"
/> </svg>"""


ICON_DATA = {
    'green': GREEN_PIPE,
    'yellow': YELLOW_PIPE,
    'red': RED_PIPE,
}

ICON_DESCRIPTIONS = {
    'green': "Green pipe",
    'yellow': "Yellow pipe",
    'red': "Red pipe",
}

TMPDIR = Path(os.getenv('XDG_RUNTIME_DIR', gettempdir())) / 'tubes'

ICON_TEMPFILES = {name: TMPDIR / f"{name}.svg" for name in ICON_DATA}


def get_icon_filpath(name):
    """Return existing tempfile filepath for icon, or create one if none exists"""
    path = ICON_TEMPFILES[name]
    if not path.exists():
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(ICON_DATA[name], 'utf8')
    return str(path)


class Gui:
    def __init__(self, shutdown_fd):
        self._indicator = AppIndicator3.Indicator.new(
            id='tubes',
            icon_name='',
            category=AppIndicator3.IndicatorCategory.SYSTEM_SERVICES,
        )
        self._indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        self._menu = Gtk.Menu()
        self._menu_item_ping_output = Gtk.MenuItem(label='')
        self._menu_item_availability_1m = Gtk.MenuItem(label='')
        self._menu_item_availability_5m = Gtk.MenuItem(label='')
        self._menu_item_availability_15m = Gtk.MenuItem(label='')
        self._menu_item_quit = Gtk.MenuItem(label='Quit')
        self._menu_item_quit.connect(
            'activate', lambda *_: os.write(shutdown_fd, b'\0')
        )

        self._menu.append(self._menu_item_ping_output)
        self._menu.append(self._menu_item_availability_1m)
        self._menu.append(self._menu_item_availability_5m)
        self._menu.append(self._menu_item_availability_15m)
        self._menu.append(self._menu_item_quit)

        self._menu.show_all()
        self._indicator.set_menu(self._menu)

    def _set_icon(self, name):
        self._indicator.set_icon_full(get_icon_filpath(name), ICON_DESCRIPTIONS[name])

    def update_ping_output(self, line):
        self._menu_item_ping_output.set_label(line)

    def update_availability(self, stats):
        fail_count, avail_1m, avail_5m, avail_15m = stats
        self._menu_item_availability_1m.set_label(
            f"Last 1 min availability: {avail_1m:.00f}%"
        )
        self._menu_item_availability_5m.set_label(
            f"Last 5 min availability: {avail_5m:.00f}%"
        )
        self._menu_item_availability_15m.set_label(
            f"Last 15 min availability: {avail_15m:.00f}%"
        )
        if fail_count == 0:
            self._set_icon('green')
        elif fail_count == 1:
            self._set_icon('yellow')
        else:
            self._set_icon('red')


class AvailabilityStats:
    def __init__(self):
        self._availability_1m = 100
        self._availability_5m = 100
        self._availability_15m = 100
        self._t_prev = time.monotonic()
        self._fail_count = 0

    def update(self, success):
        t = time.monotonic()
        dt = t - self._t_prev
        self._t_prev = t
        if dt > 2:
            # Computer was sleeping or something, don't let this affect
            # the availability stats:
            dt = 1.5

        if success:
            self._fail_count = 0
        else:
            self._fail_count += 1

        # Exponential averaging at three timescales:
        k_1 = dt / 60
        k_5 = dt / (5 * 60)
        k_15 = dt / (15 * 60)

        self._availability_1m = (
            k_1 * 100 * bool(success) + (1 - k_1) * self._availability_1m
        )
        self._availability_5m = (
            k_5 * 100 * bool(success) + (1 - k_5) * self._availability_5m
        )
        self._availability_15m = (
            k_15 * 100 * bool(success) + (1 - k_15) * self._availability_15m
        )

    def get(self):
        # Return fail count, 1m, 5m, 15m availability
        return (
            self._fail_count,
            self._availability_1m,
            self._availability_5m,
            self._availability_15m,
        )


class App:
    def __init__(self):
        # Self-pipe for clean shutdown
        self._selfpipe_r, self._selfpipe_w = os.pipe()
        signal.signal(signal.SIGINT, lambda *_: os.write(self._selfpipe_w, b'\0'))
        signal.signal(signal.SIGTERM, lambda *_: os.write(self._selfpipe_w, b'\0'))
        GLib.io_add_watch(self._selfpipe_r, GLib.IO_IN, lambda *args: self._shutdown())

        self._availability_stats = AvailabilityStats()
        self._gui = Gui(self._selfpipe_w)

        self._stdout_watch = None
        self._stderr_watch = None
        self._child = None
        self._timeout = None
        self._start_child()
        self._set_timeout()

    def _start_child(self):
        self._child = Popen(['ping', '8.8.8.8'], stdout=PIPE, stderr=PIPE)
        self._stdout_watch = GLib.io_add_watch(
            self._child.stdout.fileno(), GLib.IO_IN, lambda *_: self._read_stdout()
        )
        self._stderr_watch = GLib.io_add_watch(
            self._child.stderr.fileno(), GLib.IO_IN, lambda *_: self._read_stderr()
        )

    def _stop_child(self):
        if self._stdout_watch is not None:
            GLib.source_remove(self._stdout_watch)
            self._stdout_watch = None
        if self._stderr_watch is not None:
            GLib.source_remove(self._stderr_watch)
            self._stderr_watch = None
        if self._child is not None:
            try:
                self._child.terminate()
                self._child.wait()
            except OSError:
                pass
            self._child = None

    def _set_timeout(self):
        self._timeout = GLib.timeout_add(1500, self._do_timeout)

    def _cancel_timeout(self):
        if self._timeout is not None:
            GLib.source_remove(self._timeout)
            self._timeout = None

    def _reset_timeout(self):
        self._cancel_timeout()
        self._set_timeout()

    def _read_stdout(self):
        line = self._child.stdout.readline().decode('utf8').strip()
        self._gui.update_ping_output(line)
        if 'bytes from' in line:
            self._availability_stats.update(success=True)
            self._gui.update_availability(self._availability_stats.get())
            self._reset_timeout()
        return True

    def _read_stderr(self):
        line = self._child.stderr.readline().decode('utf8').strip()
        self._gui.update_ping_output(line)
        return True

    def _do_timeout(self):
        self._availability_stats.update(success=False)
        self._gui.update_availability(self._availability_stats.get())
        # Restart child process if it exited:
        if self._child is not None and self._child.poll() is not None:
            self._stop_child()
            self._start_child()
        return True

    def run(self):
        Gtk.main()

    def _shutdown(self):
        os.close(self._selfpipe_r)
        os.close(self._selfpipe_w)
        self._stop_child()
        self._cancel_timeout()
        Gtk.main_quit()


def main():
    app = App()
    app.run()

    # Cleanup temp files:
    for path in ICON_TEMPFILES.values():
        path.unlink(missing_ok=True)
    try:
        TMPDIR.rmdir()
    except OSError:
        pass


if __name__ == '__main__':
    main()
